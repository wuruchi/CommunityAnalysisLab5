---
title: "Lab5"
author: "Wilmer et. al. 2019"
date: "11/12/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Lab 5
```{r}
library(igraph)
library(dplyr)
```


## Reading the data
```{r}
IBEX<-read.table("data/Ibex0809.txt",sep="",header=T)
ENRON<-read.table("data/email-Enron.txt",sep="",header=T)
BRIGHTKITE<-read.table("data/loc-brightkite_edges.txt",sep="",header=T)


ENRON_sample <- data.frame(X0=numeric(), X1=numeric())
burned <- data.frame(X0=numeric())

recommended_percent <- 0.7

forest_fire_spreader = function(data, current, p) {
  burned <<- rbind(burned, data.frame(X0=c(current)))
  current_neighbor <- data[which(data$X0==current),]
  distri <- rgeom(n = 1, prob = 0.3)
  distri <- min(distri, nrow(current_neighbor))
  current_neighbor_sample <- sample_n(current_neighbor, distri)
  for (x in 1:nrow(current_neighbor_sample)) {
     ENRON_sample <<- rbind(ENRON_sample, data.frame(X0=c(current_neighbor_sample$X0[x]),X1=c(current_neighbor_sample$X1[x])))
     forest_fire_spreader(data, current_neighbor_sample$X1[x], p)
  }
}

forest_fire = function(data, p) {
  d_nodes <- distinct(data, X0)
  picked <- sample_n(d_nodes,1)
  burned <<- rbind(burned, data.frame(X0=c(picked$X0)))
  random_picked <- picked$X0
  current_neighbor <- data[which(data$X0==random_picked),]
  distri <- rgeom(n = 1, prob = 0.3)
  distri <- min(distri, nrow(current_neighbor))
  current_neighbor_sample <- sample_n(current_neighbor, distri)
  for (x in 1:nrow(current_neighbor_sample)) {
    #cat("Honk")
    ENRON_sample <<- rbind(ENRON_sample, data.frame(X0=c(current_neighbor_sample$X0[x]),X1=c(current_neighbor_sample$X1[x])))
    forest_fire_spreader(data, current_neighbor_sample$X1[x], p)
  }
}



forest_fire(ENRON)
(burned)
(ENRON_sample)

# ENRON_nodes <- distinct(ENRON,X0)
# picked <- sample_n(ENRON_nodes,1)
# random_picked <- picked$X0
# current_neighbor <- ENRON[which(ENRON$X0==random_picked),]
# #E(X) = 1/p 
# distri <- rgeom(n = 1, prob = 0.3)
# current_neighbor_sample <- sample_n(current_neighbor, distri)
# #summary(distri)


# Edge sampling without replacement
#ENRON %>% distinct(X0,X1)
#ENRON_sample <- sample_frac(ENRON, size = 0.01, replace = FALSE)
#BRIGHTKITE %>% distinct(X0,X1)
#BRIGHTKITE_sample <- sample_frac(BRIGHTKITE, size = 0.01, replace = FALSE)

```

## Sampling
```{r}

```


## Ibex Analysis
```{r}

##HIERARCHICAL CLUST on dissimilarity graph
dd <-as.dist(2*(1-cor(IBEX)))
met="ward.D2" ##  complete,single,average,median,mcquitty
hc <-hclust(dd,method=met)
plot(hc,main=paste(met," method"),axes=TRUE,xlab="",sub="")
#compute the cut at mean level K
l <-length(hc$height);hh <- sort(hc$height);K <- mean(hh[1:l])
abline(h=K,lty=2,lwd=2) ##draw the cut

#branches below K make clusters, above go to singletons
groups <- cutree(hc, h = K)  ##obtain  clusters
numgp <- max(groups) #number of clusters. 
#extract the names of each group and convert to list
W <- list(names(groups[groups==1]))

##recursively concatenate lists
for (i in 2:numgp){W <- c(W,list(names(groups[groups==i])))}
W
##Xtras
plot(hc,hang=-1) ##hang=-1 places labels at bottom

##Obtain adjacency matrix from dissimilarity relation (dist)
A<-as.matrix(dd)
##create igraph graph object from adjacency matrix
G_IBEX <-graph.adjacency(A,mode="undirected",weighted = TRUE)
plot(G_IBEX)

```

# From Data to Graphs

```{r}
dd_ibex <- as.dist(2*(1-cor(IBEX)))
#dd_enron <- as.dist(2*(1-cor(ENRON)))
#dd_bk <- as.dist(2*(1-cor(BRIGHTKITE)))



A_ibex<-as.matrix(dd_ibex)
#A_enron<-as.matrix(dd_enron)
#A_bk<-as.matrix(dd_bk)

G_IBEX <- graph.adjacency(A_ibex,mode="undirected",weighted = TRUE)
G_ENRON <-  graph.data.frame(ENRON_sample, directed = FALSE)
G_ENRON <- simplify(G_ENRON, remove.multiple = TRUE)
# G_ENRON <- graph.adjacency(A_enron,mode="undirected",weighted = TRUE)
G_BK <- graph.data.frame(BRIGHTKITE_sample, directed = FALSE)
G_BK <- simplify(G_BK, remove.multiple = TRUE)

```

help(edge.betweenness.community)
ebw <- edge.betweenness.community(G_ENRON)
com_test <- ebw[0]

test <- fc(G_ENRON, com_test, ebw)

## Metric function
```{r} 



get_edges_df <- function(G,coms){
  df<-data.frame()
  for (i in coms){
    for(edge in E(G)[from(i)]){
      h <- as.vector(head_of(G,E(G)[edge]))
      t <- as.vector(tail_of(G,E(G)[edge]))
      df <- rbind(df, data.frame(h,t))
    }
  }
}

new_subgraph <- function(G,community){
    edge_list <- get_edges_df(G, community)
    graph.data.frame(edge_list, directed = FALSE)
  }

## fc trials (failure)
  
  fc_func <- function(G,com){
    fc <- 0
    for (c in com){
      print(c)
      n <- neighbors(G,c)
      print(n)
      n_in <- intersect(n,c)
      gin <- induced_subgraph(G,n_in)
      print(V(gin))
      g <- induced_subgraph(G,c)
      gn <- induced_subgraph(G, n)
      #gout<- difference(gn,gin)
      #print(V(gout))
      inter <- intersection(g, gn)
      print(inter)
      fc <- max(E(inter))  
    }
    return(fc)
  }
  
  test <- fc_func(karate, wc[1])
  print(test)
  #problem : neighbors function also takes into consideration nodes from the community so some edges are between nodes of the same community
  
  fc2 <- function(G, cm, com){
    fc <-0
    max <- max(membership(com))
    for (i in 1:max){
      for( c in cm)
      print("community is")
      for (j in com[i])
      
      print(c)
      print(j)
      if(!isTRUE(all.equal(j,c))){
        g1 <- induced_subgraph(G,c)
        print(E(g1))
        g2 <- induced_subgraph(G, j)
        print(E(g2))
        fc <- fc +  E(intersection(g1,g2))
        print(fc)
      }
    }
  }
  test2 <- fc2(karate, wc[1], wc)
  print(test2)
  # induced_subgraph doesn't keep the value of the vertices for the new graph and then intersection of the 2 graphs are not intersections with the 2 communities (vertices renamed)

  
  fc3 <- function(G, com){
    for(c in com){
    print(c)
    edges <- get.edgelist(G,c)
    print(edges)
    if( !is.element(1,edges[4])){
      print(TRUE)
    }
    }
    
  }
  test3 <- fc3(karate, wc[1])
  print(test3)
  #
  
  fc <- function(G,com, communities){
    fc <-0
    for (c in com){
      max <- max(membership(communities))
      for(i in 0:max)
        for(coms in communities[i]){
          if (!isTRUE(all.equal(coms, c))){
            print(coms)
            print(c)
          graph1 <- new_subgraph(G, c)
          graph2 <- new_subgraph(G, com)
          g <- intersection(graph1,graph2)
          fc <- fc + max(E(g))
        }}
        
      }
    
    return(fc)
  }
  test4 <- fc(karate, wc[1], wc)
  print(test4)


  
  expansion <- function(G, com, commmunities){
    #fc <- fc(G,com, communities)
    #nc <-
    #results <- fc/nc
    
  }
  
  conductance <- function(G,com, communities){
    #fc <- fc(G,com, communities)
    #mc <-
    #results <- fc/(2*mc + fc)  
  }

fc <- function(G,com, communities){
  fc <-0
  for (c in com){
    print(c)
    for(coms in communities)
  {print(coms)
    if (!isTRUE(all.equal(coms, c))){
      graph1 <- new_subgraph(G, c)
      graph2 <- new_subgraph(G, com)
      g <- intersection(graph1,graph2)
      fc <- fc + max(E(g))
    }
  }}

  
    return(fc)
}

  

```

## Testing Algorithm Function
```{r}

compute_metrics = function(data){
    data_s <- data.frame(algorithm=character(), TPT=numeric(), expansion=numeric(), conductance=numeric(), modularity=numeric())
    finaldata_s <- rbind(data_s)
    colnames(finaldata_s) = c("Algorithm", "TPT", "Expansion","Conductance","Modularity")
    ## TODO: Loop here for all three 
    # Edge betweenness
    ebw <- edge.betweenness.community(data)
    #ebw_modularity = modularity(ebw)
    ebw_expansion = 
    ebw_result <- data.frame(algorithm = c("Edge Betweenness"),TPT= c(0), expansion= c(0), conductance=c(0), modularity=c(modularity(ebw)))
    finaldata_s <- rbind(finaldata_s,ebw_result)
    
    fgc <- fastgreedy.community(data)
    #fgc_result <- c("Fast Greedy", 0, 0, 0, fgc_modularity)
    fgc_result <- data.frame(algorithm = c("Fast Greedy"),TPT= c(0), expansion= c(0), conductance=c(0), modularity=c(modularity(fgc)))
    finaldata_s <- rbind(finaldata_s,fgc_result)
    
    lpc <- label.propagation.community(data)
    lpc_result <- data.frame(algorithm = c("Label Propagation"),TPT= c(0), expansion= c(0), conductance=c(0), modularity=c(modularity(lpc)))
    finaldata_s <- rbind(finaldata_s,lpc_result)
    
    lec <- leading.eigenvector.community(data)
    lec_result <- data.frame(algorithm = c("Leading Eigenvector"),TPT= c(0), expansion= c(0), conductance=c(0), modularity=c(modularity(lec)))
    finaldata_s <- rbind(finaldata_s,lec_result)
    
    mlvc <- multilevel.community(data)
    mlvc_result <- data.frame(algorithm = c("Multilevel"),TPT= c(0), expansion= c(0), conductance=c(0), modularity=c(modularity(mlvc)))
    finaldata_s <- rbind(finaldata_s,mlvc_result)
    
    #opc <- optimal.community(G_IBEX)
    #opc_result <- c("Optimal", 0, 0, 0, modularity(opc))
    #finaldata_s <- rbind(finaldata_s,opc_result)
    
    sgc <- tryCatch({ spinglass.community(data) }, error=function(cond) { return(0) }) 
    if (identical(sgc, 0)) {
      modularity_val <- NA
    } else {
      modularity_val <- modularity(sgc)
    }
    sgc_result <- data.frame(algorithm = c("Spinglass"),TPT= c(0), expansion= c(0), conductance=c(0), modularity=c(modularity_val))
    finaldata_s <- rbind(finaldata_s,sgc_result)
    
    wtc <- walktrap.community(data)
    wtc_result <- data.frame(algorithm = c("Walktrap"),TPT= c(0), expansion= c(0), conductance=c(0), modularity=c(modularity(wtc)))
    finaldata_s <- rbind(finaldata_s,wtc_result)
    
    imc <- infomap.community(data)
    imc_result <- data.frame(algorithm = c("Infomap"),TPT= c(0), expansion= c(0), conductance=c(0), modularity=c(modularity(imc)))
    
    finaldata_s <- rbind(finaldata_s,imc_result)
    
    return(finaldata_s)
}



#🐗
```

## Tests
```{r}
ibex_results <- compute_metrics(G_IBEX)
enron_results <- compute_metrics(G_ENRON)
bk_results <- compute_metrics(G_BK)
```

## Show tests
```{r}
ibex_results
enron_results
bk_results
```

# Test
```{r}
help("spinglass.community")
```

